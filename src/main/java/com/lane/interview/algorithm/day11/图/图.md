## 图

## 简介

[.pdf](assets/数据结构---图-知乎.pdf)

## 难点

能表达图的数据结构有很多

比如邻接矩阵、邻接表、二维矩阵[weight, from节点上面的值，to节点上面的值]、一维数组(索引到元素有路，表示不了权重)

所以不同的表达都需要会

### 宽度优先遍历

1.利用队列实现(需要额外一个set用来去重，因为图结构可能节点与节点之间有回路，入队列的时候也需要入这个set)

2.从源节点开始依次按照宽度进队列，然后弹出

3.每弹出一个点，把该节点所有的没有进过队列的邻接点放入队列

4.直到队列变空

### 深度优先遍历

（先选一条路，没走完就走到尽头(但是不能走回头路)，走完之后回溯寻找分岔路口）

也需要额外一个set用来去重

set的作用：①避免走环路②避免回溯的时候打印重复的点

1.利用栈实现

2.从源节点开始把节点按照深度放入栈，然后弹出

3.每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈

4.直到栈变空

### 拓扑排序

1.在图中找到所有入度为0的输出

2.把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始

3.图的所有点都被删除后，依次输出的顺序就是拓扑排序

要求：有向图且无环

应用：事件安排、编译顺序 做完了a才能做b，做完了a&b才能做c→a,b,c

注意：拓扑排序的结构不一定唯一

A→B A→C B→D C→D

答案可以是ABCD也可以是ACBD

### 最小生成树算法之Kruskal

需要使用并查集，能不能形成环其实就是两个点在不在一个集合里(isSameSet)

1.总是从权值最小的边开始考虑，依次考察权值依次变大的边

2.当前的边要么进入最小生成树的集合，要么丢弃

3.如果当前的边进入最小生成树的集合中不会形成环，就要当前边

4.如果当前的边进入最小生成树的集合中会形成环，就不要当前边

5.考察完所有的边之后，最小生成树的集合也得到了

### 最小生成树算法之Prim

点解锁边，边解锁点，周而复始

1.可以从任意节点出发来寻找最小生成树

2.某个点加入到被选取的点中后，解锁这个点触发的所有新的边

3.在所有解锁的边中选最小的边，然后看看这个边会不会形成环

4.如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3

5.如果不会，要当前边，将该边的指向点加入到被选取的点钟，重复2

6.当所有的点都被选取，最小生成树就得到了
